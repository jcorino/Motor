'****************************************************************
'*  Name    : MOTOR.pbp                                        *
'*  Author  : Juan Manuel Corino                                *
'*  Notice  : Copyright (c) 2018 Juan Manuel Corino             *
'*          : All Rights Reserved                               *
'*  Date    : 01/05/2018                                        *
'*  Version : 1.1                                               *
'*  Notes   : 16F887 @ 20Mhz                                   *
'*          :                                                   *
'****************************************************************
              'Test debug
'##################################################################
'Grabado Valores Iniciales en EEprom - Tabla db y parametros DSP
'Data @0,    0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,4

'Posicion 0-1 RESERVADA minEncoder
'Posicion 2-3 RESERVADA maxEncoder
        
'###################################################################
  
'#IF __PROCESSOR__ = "16F887"
    '#CONFIG 
   '__config _FOSC_HS & _WDT_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _LVP_OFF & _DEBUG_OFF &  _WRT_OFF & _BOR40V
  '#ENDCONFIG
'#endif

INCLUDE "modedefs.bas"
Define LOADER_USED	1
DEFINE OSC 20           	'20Mhz Oscillator was used
'DEFINE HSER_CLROERR 1       'Hser clear overflow automatically
DEFINE SHIFT_PAUSEUS 10 

'CMCON = 7
ansel = 0
anselh = 0
IOCB = 0

rcsta = $90                 'Enable Asynchronous Serial Receive
txsta = $24                 'Enable Asynchronous Serial Transmit
'ICD---------------------
'spbrg = 64                  '19.2 KBaud @ 20Mhz
spbrg = 10                  '115.2 KBaud @ 20Mhz
'--------------------------
'option_reg = $87			'Set timer0 in TimerMode and prescaler 1:128
t1con = $25                 'Set Timer1 in TimerMode Prescaler 1:4
intcon.0 = 0
intcon.1 = 0
intcon.3 = 0
intcon.4 = 0
'intcon = 0

'intcon2.7 = 1              '18F4520
OPTION_REG.7 = 1            '16F887

TRISA.1 = 0                 'PIN 2 - Salida Seleccion LOW/HIGH Byte Encoder.
TRISA.0 = 0                 'PIN 3 - Salida Leer datos Encoder.

TRISA.2 = 1                 'PIN 4 - Entrada general 1.
TRISA.3 = 1                 'PIN 5 - Entrada general 2.
TRISA.4 = 1                 'PIN 6 - Entrada general 3.

TRISA.5 = 0                 'PIN 7 - Salida general 1.
TRISE.0 = 0                 'PIN 8 - Salida general 2.
TRISE.1 = 0                 'PIN 9 - Salida general 3. 

'TRISB.0 = 0                 'PIN 33 - Salida Boton Subir.
'TRISB.1 = 0                 'PIN 34 - Salida Boton Bajar.
'TRISB.2 = 0                 'PIN 35 - Salida Selector vel 1.
'TRISB.3 = 0                 'PIN 36 - Salida Selector vel 2.
'TRISB.4 = 0                 'PIN 37 - Salida Selector vel 3.

trisb = 0
portb = 0

TRISC.1 = 0                 'PIN 16 - Salida control TX RS485.

TRISC.2 = 0                 'PIN 17 - Salida Control Escritura EEPROM.
TRISC.3 = 0                 'PIN 18 - Salida SCK.
'TRISC.4 = 1                 'PIN 23 - Salida SDI.

TRISD.0 = 1                 'PIN 19 - Entrada encoder 0.
TRISD.1 = 1                 'PIN 20 - Entrada encoder 1.
TRISD.2 = 1                 'PIN 21 - Entrada encoder 2.
TRISD.3 = 1                 'PIN 22 - Entrada encoder 3.
TRISD.4 = 1                 'PIN 27 - Entrada encoder 4.
TRISD.5 = 1                 'PIN 28 - Entrada encoder 5.
TRISD.6 = 1                 'PIN 29 - Entrada encoder 6.
TRISD.7 = 1                 'PIN 30 - Entrada encoder 7.

'#################################################################
'Subir               VAR PORTB.0
'Bajar               VAR PORTB.1

DPIN                VAR PORTC.4         'I2C data pin
CPIN                VAR PORTC.3         'I2C clock pin
PORTC.2 = 0                             'TIENE QUE ESTAR EN 0 PARA QUE FUNCIONEN LAS MEMORIAS
tx485               var PORTC.1         'Control TX RS485.

'#################################################################

NroMotor            CON 1
NroMen              CON %10100000

ToSend              var byte

StatusByte          VAR BYTE    'StatusByte Se transmite siempre
ConfirmByte         VAR BYTE    'Este Byte se envia como confirmacion de la ultima trama recibida
StatusByte2         VAR BYTE    'StatusByte2 Se transmite si no tengo que informar limites
StatusByte3         VAR BYTE    'StatusByte3 Se transmite si no tengo que informar limites
StatusByte4         var byte    'OJO StatusByte4 se transmite siempre pero no puede ser=255
                                'sino el receptor creeria que estoy informando limites
                                'En rutina TX: si esta en 255 la paso a 254 por precaucion.
                                
tmpSubir            VAR StatusByte.1
tmpBajar            VAR StatusByte.2
Automatic           VAR StatusByte.3        'Esta en 1 si esta haciendo GoAutomatic
LimSupSup           VAR StatusByte.4        'Si se supero Limite Superior
LimInfSup           VAR StatusByte.5        'Si se supero Limite Inferior

hexRX               var byte
binRX               var byte
indiceRXarray       var byte
temp                VAR BYTE
tempRC              var byte

Deep                VAR BYTE
Ac_Seg              VAR BYTE
timeout             VAR BYTE
timeoutRX           VAR bit
TXBYTE              VAR BYTE
Encoder             VAR WORD
Ac_MS               VAR BYTE

targetEncoder       VAR WORD
Mayor               VAR BIT

CRC2				VAR	BYTE
CRC					VAR	byte

Vel                 VAR BYTE

maxEncoder          VAR WORD
minEncoder          VAR WORD

InfLimit            var bit
antTargetEncoder    var word
Pkt                 VAR BYTE[20]
RXArray             VAR BYTE[10]

'#################################################################

Start:              'Inicio. LLamarla implica Soft-Reset

    Clear           'Inicializar todas las variables a cero
    portb = 0
    tx485 = 0
    TXSTA.5 = 0   			'Me aseguro de que este apagado transmisor
    
    pir1.0 = 0      'Cargo Timer
    TMR1L = 243
    TMR1H = 11
'#################################################################

read 0, temp
minEncoder.lowBYTE = temp
read 1, temp
minEncoder.HIGHBYTE = temp

read 2, temp
maxEncoder.lowBYTE = temp
read 3, temp
maxEncoder.HIGHBYTE = temp
          
Encoder = 32000

'DEBUG
portb.0 = 1
portb.1 =1
pause  1000
portb.0 = 0
portb.1 =0


Loopp:

    IF pir1.0 = 1 Then 
        pir1.0 = 0
        TMR1L = 243
        TMR1H = 11
        GoSub subEncoder
        GoSub Timer_Sub
    EndIF
    'GoSub INMEDIATE_TX     'DEBUG
    minEncoder = 0         'DEBUG
    maxencoder = 65535     'DEBUG
    GoSub CheckRX
    
    GoTo Loopp
    
Timer_Sub:
    
    'if timeoutRX = 1 then      'Si no recibe un byte por 50ms despues que comenzo
    '    Deep = 0               'a recibir una trama, aborta la trama completa
    'endif
    'timeoutRX = 1     
    
    IF timeout >= 4 Then   '200ms
        tmpbajar = 0
        tmpsubir = 0
        timeout = 0
        automatic = 0	'########################
    Else
        timeout = timeout + 1
    EndIF 
    
    IF Automatic = 1 Then
        GoSub GoAutomatic
    EndIF
    
    Ac_MS = Ac_MS + 1
    
    IF Ac_MS.0 = 1 Then        'Entro cada 100ms
    
        gosub CheckLimits
        
    EndIF
   
    if Ac_Seg >= 60 then    'Entro cada 3 Segundo
        Ac_Seg = 0
        inflimit = 1
    else
        'Encoder = Encoder + 1 'DEBUG
        'gosub INMEDIATE_TX    'DEBUG
        Ac_Seg = Ac_Seg +1
    endif
    
    Return
    
INMEDIATE_TX:
        
        CRC = 0
        tx485 = 1
		TXSTA.5 = 1                             'Activar transmisor
		
        TXBYTE = ":"                            'Envio inicio de trama 
        GoSub TX
        
        if inflimit = 1 then                    'Campo 1
            tosend = 255                        'Esta Informando Limites
            GoSub AsciiToHexTX
            CRC = CRC ^ 255 
            
            tosend = maxencoder.highbyte        'Campo 2
            CRC = CRC ^ maxencoder.highbyte     'LimiteSup highbyte
            GoSub AsciiToHexTX 
       
            tosend = maxencoder.lowbyte         'Campo 3
       	    CRC = CRC ^ maxencoder.lowbyte      'LimiteSup lowbyte
       	    GoSub AsciiToHexTX
       	    
       	    tosend = minEncoder.highbyte        'Campo 4
            GoSub AsciiToHexTX                  'LimiteInf highbyte
            CRC = CRC ^ minencoder.highbyte
            
            tosend = minEncoder.lowbyte         'Campo 5
            GoSub AsciiToHexTX                  'LimiteInf lowbyte   
            CRC = CRC ^ minencoder.lowbyte
            
            inflimit = 0
            
        else
            
            if Statusbyte4 = 255 then       'Campo 1
                statusbyte4 = 254           'Statusbyte4
            endif                           'OJO esta variable no puede ser 255 sino el receptor
            tosend = statusbyte4            'creeria que estoy informando limites    
            CRC = CRC ^ statusbyte4
            GoSub AsciiToHexTX        
       
            tosend = StatusByte3            'Campo 2
            CRC = CRC ^ StatusByte3         'StatusByte3
            GoSub AsciiToHexTX        
        
            tosend = StatusByte2            'Campo 3 
       	    CRC = CRC ^ StatusByte2         'StatusByte2
       	    GoSub AsciiToHexTX
       	    
            tosend = Encoder.highbyte       'Campo 4
            GoSub AsciiToHexTX              'Encoder actual highbyte
            CRC = CRC ^ Encoder.highbyte
            
            tosend = Encoder.lowbyte        'Campo 5
            GoSub AsciiToHexTX              'Encoder actual lowbyte     
            CRC = CRC ^ Encoder.lowbyte
            
        endif
        
            tosend = ConfirmByte            'Campo 6
            CRC = CRC ^ ConfirmByte         'ConfirmByte 
            GoSub AsciiToHexTX
            ConfirmByte = 0
            
            tosend = StatusByte             'Campo 7
            GoSub AsciiToHexTX              'StatusByte
            CRC = CRC ^ StatusByte          
            
            tosend = vel                    'Campo 8
            CRC = CRC ^ vel                 'Velocidad
            GoSub AsciiToHexTX
        
            tosend = NroMotor               'Campo 9
            GoSub AsciiToHexTX              'Nro Motor      
            CRC = CRC ^ NroMotor
            
            tosend = CRC                    'Campo 10
            GoSub AsciiToHexTX              'CRC          
                                                
            TXBYTE = 13                     'Transmito Cr + Lf
            GoSub TX
            
            TXBYTE = 10
            GoSub TX
            
        pauseus 500                  'Espero que transmita ultimo byte
        TXSTA.5 = 0   			     'Me aseguro de que este apagado transmisor
		tx485 = 0
  Return

'################################################################################
'RUTINAS DE TRANSMISION PUERTO SERIE HARD
'SI QUIERO ENVIAR EL ASCII EQUIVALENTE AL HEXA TENGO QUE 
'CARGAR ToSend CON CON EL BYTE A ENVIAR Y LLAMAR A AsciiToHexTX:
'ESTO VA A ENVIAR DOS CARACTERES POR EL PUERTO SERIE.
'EJEMPLO: ToSend = 255 ----> Envia caracter "F" + "F"
'Si quiero enviar el caracter binario cargar TXBYTE y llamar a TX:

AsciiToHexTX:
 
        temp = tosend >> 4        'Aislo 4 bits mas significativos
        GOSUB TXHex
        
        temp = tosend & %00001111 'Aislo 4 bits menos significativos 
        GOSUB TXHex
        return

TXHex:     
        lookup temp, ["0123456789ABCDEF"],TXBYTE 
        
TX:     
        IF PIR1.4 = 0 Then GoTo TX       'PIR1.4 = TXIF
        TXREG = TXBYTE
        Return
'################################################################################        
     
     
   
CheckRX:    
            
        IF rcsta.1 = 1 Then         'OverRun del Buffer de Recepcion
			RCSTA.4=0               'Inicializar Receptor
			RCSTA.4=1   		    'Inicializar Receptor
            Deep = 0
            return
        EndIF
        
	    IF PIR1.5 = 0 Then Return   '1 = hay datos en el buffer.
        
        if RCSTA.2 then             'Framing Error bit
		  tempRC = RCREG            'tengo que descartar ese byte
		  Deep = 0
          return                    'por eso lo leo para sacarlo del
        Else                        'Buffer
          tempRC = RCREG            
        endif                       
        
        if deep =0 then
            if temprc <> "@" then
                Deep = 0
            else
                pkt[0]="@"
                Deep = 1
                For temp = 1 TO 19
					Pkt[temp] = 0
 				Next temp
 			endif
            return   
        endif 
             
        if deep <18 then
                pkt[deep]=temprc
                if pkt[deep] = "@" then     'Si llega un "@" es que comenzo otra trama
                    deep = 1
                    return
                endif
                Deep = deep + 1
                return
        endif
        
        if deep = 18 then
            pkt[deep]=temprc
            if pkt[deep] = "@" then     'Si llega un "@" es que comenzo otra trama
                deep = 1
                return
            endif
                
            'Termino de recibir trama completa
            'hay que procesarla, chequear CRC y nroMotor.
            'Actuar en concecuencia.
            
            'Genero Array de Bytes RX Bin. Pasando la representacion Hex
            'que recibo a su equivalente en bytes Binario.
            'RXArray[0] = 64 "@" Inicio de trama
            'RXArray[1] = Numero de motor
            'RXArray[2] = Accion
            'RXArray[3] = Posicion MSB
            'RXArray[4] = Posicion LSB
            'RXArray[5] = TargetPos MSB
            'RXArray[6] = TargetPos LSB
            'RXArray[7] = Velocidad
            'RXArray[8] = Numero de confirmacion - ConfirmByteRX
            
            RXArray[0] = 64 ' "@"
            indiceRXarray = 0
            for temp = 1 to 17 step 2
                indiceRXarray = indiceRXarray+1
                hexRX =  pkt[temp]
                gosub HexToAscii
                RXArray[indiceRXarray] = binRX <<4
                hexRX =  pkt[temp+1]
                gosub HexToAscii
                RXArray[indiceRXarray] = RXArray[indiceRXarray] | binRX
            next temp
            
            'Calculo CRC
            CRC2 = 64   '"@"
            for temp = 1 to 8
                 CRC2 = CRC2 ^ RXArray[temp]
            next temp
            
            if CRC2 <> RXArray[9] then
                Deep = 0
                return
            endif
            
            if RXArray[1]<> nromotor then
                deep = 0
                return
            endif
            Deep = 0
            
            'La trama paso todas las pruebas.
            'A partir de aca a procesar.
            
            'Los posibles valores que puedo recibir en Accion son los
            'determinados en el enum ComandoMotor (Soft PC):
            'cReset = 1
            'cReporte = 2
            'cSubir = 3
            'cBajar = 4
            'cStop = 5
            'cStopGoAutomatic = 6
            'cGoAutomatic = 7
            'cActualizarLimites = 8
' "p"       Reset equipo - Utilizada en PICs con reset por soft (18F)
' "g"       Transmitir a soft PC limites, posicion, etc, etc - Es la que utilizo para reportar
' "a"       Comando Subir
' "z"       Comando Bajar
' "x"       Comando Stop
' "j"       Detener GoAutomatic DEBO UTILIZARLA - IMPLEMENTAR CODIGO
' "k"       Comando ir a automaticamente
' "s"       Comando actualizar final de carrera minEncoder
' "d"       Comando actualizar final de carrera maxEncoder

' "r"       Comando Reproducir Rutina grabada en EEPROM - NO UTILIZADA
' "b"       Comenzar a Grabar Datos PC a SD - NO UTILIZADA
' "c"       Comenzar a Grabar de PC a SD - NO UTILIZADA	
' "r"       Comando Reproducir Rutina grabada en EEPROM - NO UTILIZADA
' "l"       Comando Comenzar Grabacion Rutina en EEPROM   - NO UTILIZADA
' "q"       Comando Enviar Rutina a PC - NO UTILIZADA
' "n"       Comando Finalizar Grabacion o Reproduccion Rutina en EEPROM - NO UTILIZADA
       
                                        
            ConfirmByte = rxarray[8]    'Este es el numero que debo enviar para chequear
                                        'que recibi ok la trama
            
            IF rxarray[2] = 1 Then	     'Reset equipo
                '@ reset
                Return
            EndIF
            
            IF rxarray[2] = 2 Then	     'Transmitir a soft PC, posicion, etc, etc
                GoSub INMEDIATE_TX
                Return
            EndIF
               
            IF rxarray[2] = 3 Then	     'Comando Subir
                tmpSubir = 1
                tmpBajar = 0
                timeout = 0
                Vel = rxarray[7]
                inflimit = 0                'Para que en la proxima trama no informe limites.
                gosub inmediate_tx   'DEBUG
                Return
            EndIF
          
            IF rxarray[2] = 4 Then	     'Comando Bajar
                tmpSubir = 0
                tmpBajar = 1
                timeout = 0
                Vel = rxarray[7]
                inflimit = 0                'Para que en la proxima trama no informe limites.
                gosub inmediate_tx   'DEBUG
                Return  
            EndIF
            
            IF rxarray[2] = 5 Then	     'Comando Stop
                tmpSubir = 0
                tmpBajar = 0
                timeout = 0
                PORTB.0 = 0
                PORTB.1 = 0
                inflimit = 0                'Para que en la proxima trama no informe limites.
                gosub inmediate_tx   'DEBUG
                Return
            EndIF
            
            'IF rxarray[2] =  Then	     'Detener GoAutomatic
                ' IMPLEMENTAR CODIGO PARA DETERNER AUTOMATICOS
            '    Return
            'EndIF
         
            IF rxarray[2] = 7 Then	     'Comando ir a automaticamente
                
                inflimit = 0                'Para que en la proxima trama no informe limites.
                gosub inmediate_tx   'DEBUG
                
                Automatic = 1
                'timeout = 0
                Vel = rxarray[7]
                targetEncoder.HIGHBYTE = RXArray[3]
                targetEncoder.lowbyte = RXArray[4]
                
                if antTargetEncoder = Targetencoder then return
                
                antTargetEncoder = TargetEncoder
                'Para que quede en una posicion fija dentro de una ventana.
                'y no tienda a no encontrar un punto fijo
                if targetencoder < (encoder + 30) and targetencoder > (encoder - 30) then return
                    
                if encoder > targetencoder then
                    Mayor =1
                    tmpSubir = 0
                    tmpBajar = 1
                else
                    Mayor = 0
                    tmpSubir = 1
                    tmpBajar = 0
                endif
                Return
            EndIF
            return
         endif   
        
            IF rxarray[2] = 8 Then	     'Comando actualizar final de carrera minEncoder
                
                maxEncoder.HIGHBYTE = RXArray[3]
                temp = maxEncoder.HIGHBYTE
                write 3, temp
                pause 5
                
                maxEncoder.lowbyte = RXArray[4]
                temp = maxEncoder.lowbyte
                write 2, temp
                pause 5
                
                minEncoder.HIGHBYTE = RXArray[5]
                temp = minEncoder.HIGHBYTE
                write 1, temp
                pause 5
                
                minEncoder.lowbyte = RXArray[6]
                temp = minEncoder.lowbyte
                write 0, temp
                pause 5
           
            endif
		
                   
        IF PIR1.5 = 1 then goto CheckRX
        return
 
 
HexToAscii:
        lookdown hexRX, ["0123456789ABCDEF"],binRX
        return

subEncoder:
    if portb.0 = 1 then         'DEBUG
        encoder = encoder + 1   'DEBUG
        return                  'DEBUG
    endif                       'DEBUG
    if portb.1 = 1 then         'DEBUG
        encoder = encoder - 1   'DEBUG
        return                  'DEBUG
    endif                       'DEBUG
    return                      'DEBUG
    
    porta.0 = 1 'Latch encoder
    pauseus 100
    encoder.highbyte = portd
    porta.1 = 1
    pauseus 20
    encoder.lowbyte = portd
    porta.1 = 0
    porta.0 = 0
    
    timeout = 0    
    Return

GoAutomatic:

    timeout = 0
    GoSub subEncoder

    IF Mayor = 1 Then
        IF encoder <= targetencoder Then
           tmpSubir = 0
           tmpBajar = 0
           PORTB.0 = 0
           PORTB.1 = 0
           timeout = 0
           automatic = 0
            portb.4=0
            portb.3=0
            portb.2=0
        EndIF
    Else
        IF encoder >= targetencoder Then
           tmpSubir = 0
           tmpBajar = 0
           PORTB.0 = 0
           PORTB.1 = 0
           timeout = 0
           automatic = 0
            portb.4=0
            portb.3=0
            portb.2=0
        EndIF
    EndIF

    Return

CheckLimits:
       'return
        '***********************************************
        'Rutina para comandar las salidas de Up/Down
        'previo chequear los limites de carrera
        '***********************************************
    if porta.3 = 1 then   ' SI ESTA EN PAUSA
        PORTB.1 = 0
        PORTB.0 = 0 
        timeout = 0
        portb.4=0         'ACA Baja velocidad a 0 cuando esta en pausa
        portb.3=0                  
        portb.2=0
        return
    endif
    
    if vel = 0 then                 
        portb.4=0                  
        portb.3=0
        portb.2=0
    endif
    if vel = 1 then
        portb.4=0
        portb.3=0
        portb.2=1
    endif
    if vel = 2 then
        portb.4=0
        portb.3=1
        portb.2=0
    endif
    if vel = 3 then
        portb.4=0
        portb.3=1
        portb.2=1
    endif
    if vel = 4 then
        portb.4=1
        portb.3=0
        portb.2=0
    endif
    if vel = 5 then
        portb.4=1
        portb.3=0
        portb.2=1
    endif
    if vel = 6 then
        portb.4=1
        portb.3=1
        portb.2=0
    endif
    if vel >= 7 then
        portb.4=1
        portb.3=1
        portb.2=1
    endif
    
    
    
        if encoder >= maxEncoder then
            PORTB.0 = 0
            tmpSubir = 0
            'automatic = 0	'########################
            LimSupSup = 1
        else
            LimSupSup = 0
            'PORTB.0 = tmpsubir
            portb.0 = tmpsubir
        endif            
        if encoder =< minEncoder then
            PORTB.1 = 0
            tmpbajar = 0
            'automatic = 0	'########################
            liminfsup = 1
        else
            liminfsup = 0
            'PORTB.1 = tmpbajar
            portb.1 = tmpbajar
        endif
return
   
End
