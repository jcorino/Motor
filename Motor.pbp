'****************************************************************
'*  Name    : MOTOR.pbp                                        *
'*  Author  : Juan Manuel Corino                                *
'*  Notice  : Copyright (c) 2018 Juan Manuel Corino             *
'*          : All Rights Reserved                               *
'*  Date    : 01/05/2018                                        *
'*  Version : 1.1                                               *
'*  Notes   : 16F887 @ 20Mhz                                   *
'*          :                                                   *
'****************************************************************
              'Test debug
'##################################################################
'Grabado Valores Iniciales en EEprom - Tabla db y parametros DSP
'Data @0,    0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,4

'Posicion 0-1 RESERVADA minEncoder
'Posicion 2-3 RESERVADA maxEncoder
        
'###################################################################
  
'#IF __PROCESSOR__ = "16F887"
    '#CONFIG 
   '__config _FOSC_HS & _WDT_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _LVP_OFF & _DEBUG_OFF &  _WRT_OFF & _BOR40V
  '#ENDCONFIG
'#endif

INCLUDE "modedefs.bas"
Define LOADER_USED	1
DEFINE OSC 20           	'20Mhz Oscillator was used
'DEFINE HSER_CLROERR 1       'Hser clear overflow automatically
DEFINE SHIFT_PAUSEUS 10 

'CMCON = 7
ansel = 0
anselh = 0
IOCB = 0

rcsta = $90                 'Enable Asynchronous Serial Receive
txsta = $24                 'Enable Asynchronous Serial Transmit
'ICD---------------------
'spbrg = 64                  '19.2 KBaud @ 20Mhz
spbrg = 10                  '115.2 KBaud @ 20Mhz
'--------------------------
'option_reg = $87			'Set timer0 in TimerMode and prescaler 1:128
t1con = $25                 'Set Timer1 in TimerMode Prescaler 1:4
intcon.0 = 0
intcon.1 = 0
intcon.3 = 0
intcon.4 = 0
'intcon = 0

'intcon2.7 = 1              '18F4520
OPTION_REG.7 = 1            '16F887

TRISA.1 = 0                 'PIN 2 - Salida Seleccion LOW/HIGH Byte Encoder.
TRISA.0 = 0                 'PIN 3 - Salida Leer datos Encoder.

TRISA.2 = 1                 'PIN 4 - Entrada general 1.
TRISA.3 = 1                 'PIN 5 - Entrada general 2.
TRISA.4 = 1                 'PIN 6 - Entrada general 3.

TRISA.5 = 0                 'PIN 7 - Salida general 1.
TRISE.0 = 0                 'PIN 8 - Salida general 2.
TRISE.1 = 0                 'PIN 9 - Salida general 3. 

'TRISB.0 = 0                 'PIN 33 - Salida Boton Subir.
'TRISB.1 = 0                 'PIN 34 - Salida Boton Bajar.
'TRISB.2 = 0                 'PIN 35 - Salida Selector vel 1.
'TRISB.3 = 0                 'PIN 36 - Salida Selector vel 2.
'TRISB.4 = 0                 'PIN 37 - Salida Selector vel 3.

trisb = 0
portb = 0

TRISC.1 = 0                 'PIN 16 - Salida control TX RS485.

TRISC.2 = 0                 'PIN 17 - Salida Control Escritura EEPROM.
TRISC.3 = 0                 'PIN 18 - Salida SCK.
'TRISC.4 = 1                 'PIN 23 - Salida SDI.

TRISD.0 = 1                 'PIN 19 - Entrada encoder 0.
TRISD.1 = 1                 'PIN 20 - Entrada encoder 1.
TRISD.2 = 1                 'PIN 21 - Entrada encoder 2.
TRISD.3 = 1                 'PIN 22 - Entrada encoder 3.
TRISD.4 = 1                 'PIN 27 - Entrada encoder 4.
TRISD.5 = 1                 'PIN 28 - Entrada encoder 5.
TRISD.6 = 1                 'PIN 29 - Entrada encoder 6.
TRISD.7 = 1                 'PIN 30 - Entrada encoder 7.

'#################################################################
'Subir               VAR PORTB.0
'Bajar               VAR PORTB.1

DPIN                VAR PORTC.4         'I2C data pin
CPIN                VAR PORTC.3         'I2C clock pin
PORTC.2 = 0                             'TIENE QUE ESTAR EN 0 PARA QUE FUNCIONEN LAS MEMORIAS
tx485               var PORTC.1         'Control TX RS485.

'#################################################################

NroMotor            CON 1
NroMen              CON %10100000

ToSend              var byte

StatusByte          VAR BYTE    'StatusByte Se transmite siempre
ConfirmByte         VAR BYTE    'Este Byte se envia como confirmacion de la ultima trama recibida
StatusByte2         VAR BYTE    'StatusByte2 Se transmite si no tengo que informar limites
StatusByte3         VAR BYTE    'StatusByte3 Se transmite si no tengo que informar limites
StatusByte4         var byte    'OJO StatusByte4 se transmite siempre pero no puede ser=255
                                'sino el receptor creeria que estoy informando limites
                                'En rutina TX: si esta en 255 la paso a 254 por precaucion.
                                
inPause             var StatusByte.0        '
tmpSubir            VAR StatusByte.1
tmpBajar            VAR StatusByte.2
Automatic           VAR StatusByte.3        'Esta en 1 si esta haciendo GoAutomatic.
LimSupSup           VAR StatusByte.4        'Si se supero Limite Superior.
LimInfSup           VAR StatusByte.5        'Si se supero Limite Inferior.
Full                var StatusByte.6        'Si el Buffer de rutinas esta lleno.
Empty               var StatusByte.7        'Si tiene rutinas en el Buffer de rutinas.

hexRX               var byte
binRX               var byte
indiceRXarray       var byte
temp                VAR BYTE
tempRC              var byte

Deep                VAR BYTE
Ac_Seg              VAR BYTE
timeout             VAR BYTE
timeoutRX           VAR bit
TXBYTE              VAR BYTE
Encoder             VAR WORD
Ac_MS               VAR BYTE

targetEncoder       var word 
GoEncoder           VAR WORD[5]
Acces_GoEncoder     var GoEncoder.byte0 'Para poder acceder a los Bytes de GoEncoder
goVel               VAR BYTE[5]
Vel                 VAR BYTE
GoPause             var byte[5]
AutomaticPause      var word

RD                  var byte
WR                  var byte

Mayor               VAR BIT

CRC2				VAR	BYTE
CRC					VAR	byte

maxEncoder          VAR WORD
minEncoder          VAR WORD

InfLimit            var bit
Pkt                 VAR BYTE[20]
RXArray             VAR BYTE[10]

'#################################################################

Start:              'Inicio. LLamarla implica Soft-Reset

    Clear           'Inicializar todas las variables a cero
    portb = 0
    tx485 = 0
    TXSTA.5 = 0   	'Me aseguro de que este apagado transmisor
    
    pir1.0 = 0      'Cargo Timer
    TMR1L = 243
    TMR1H = 11
'#################################################################

'Inicicalizo variables BufferRutinas
empty =1
full=0

read 0, temp
minEncoder.lowBYTE = temp
read 1, temp
minEncoder.HIGHBYTE = temp

read 2, temp
maxEncoder.lowBYTE = temp
read 3, temp
maxEncoder.HIGHBYTE = temp
          
Encoder = 5000
'minEncoder = 0         'DEBUG
'maxencoder = 65535     'DEBUG


Loopp:

    IF pir1.0 = 1 Then 
        pir1.0 = 0
        TMR1L = 243
        TMR1H = 11
        GoSub subEncoder
        GoSub Timer_Sub
    EndIF
    
    GoSub CheckRX
    
    GoTo Loopp
    
Timer_Sub:
    
    'if timeoutRX = 1 then      'Si no recibe un byte por 50ms despues que comenzo
    '    Deep = 0               'a recibir una trama, aborta la trama completa
    'endif
    'timeoutRX = 1     
    
    IF timeout >= 4 Then   '200ms
        tmpbajar = 0
        tmpsubir = 0
        timeout = 0
        'automatic = 0	'########################
    Else
        timeout = timeout + 1
    EndIF 
    
    'Si estoy en automatic y AutomaticPause es mayor a 50
    'voy restando de a 50 milisegundos. Cuando esta por debajo
    'de 50 tengo que ponerlo en 0 y cortar automatic ya
    'que termino la pausa.
    if automatic = 1 then
        if AutomaticPause >50 then
           AutomaticPause = AutomaticPause - 50
        else
            if AutomaticPause > 0 then
                AutomaticPause = 0
                automatic = 0
            endif
        endif
    endif
     
    GoSub GoAutomatic
    
    Ac_MS = Ac_MS + 1
    
    IF Ac_MS.0 = 1 Then        'Entro cada 100ms
    
        gosub CheckLimits
        
    EndIF
   
    if Ac_Seg >= 60 then    'Entro cada 3 Segundo
        Ac_Seg = 0
        inflimit = 1
    else
        Ac_Seg = Ac_Seg +1
    endif
    
    Return
    
INMEDIATE_TX:
        
        CRC = 0
        tx485 = 1
		TXSTA.5 = 1                             'Activar transmisor
		
        TXBYTE = ":"                            'Envio inicio de trama 
        GoSub TX
        
        if inflimit = 1 then                    'Campo 1
            tosend = 255                        'Esta Informando Limites
            GoSub AsciiToHexTX
            CRC = CRC ^ 255 
            
            tosend = maxencoder.highbyte        'Campo 2
            CRC = CRC ^ maxencoder.highbyte     'LimiteSup highbyte
            GoSub AsciiToHexTX 
       
            tosend = maxencoder.lowbyte         'Campo 3
       	    CRC = CRC ^ maxencoder.lowbyte      'LimiteSup lowbyte
       	    GoSub AsciiToHexTX
       	    
       	    tosend = minEncoder.highbyte        'Campo 4
            GoSub AsciiToHexTX                  'LimiteInf highbyte
            CRC = CRC ^ minencoder.highbyte
            
            tosend = minEncoder.lowbyte         'Campo 5
            GoSub AsciiToHexTX                  'LimiteInf lowbyte   
            CRC = CRC ^ minencoder.lowbyte
            
            inflimit = 0
            
        else
            
            if Statusbyte4 = 255 then       'Campo 1
                statusbyte4 = 254           'Statusbyte4
            endif                           'OJO esta variable no puede ser 255 sino el receptor
            tosend = statusbyte4            'creeria que estoy informando limites    
            CRC = CRC ^ statusbyte4
            GoSub AsciiToHexTX        
       
            tosend = StatusByte3            'Campo 2
            CRC = CRC ^ StatusByte3         'StatusByte3
            GoSub AsciiToHexTX        
        
            tosend = StatusByte2            'Campo 3 
       	    CRC = CRC ^ StatusByte2         'StatusByte2
       	    GoSub AsciiToHexTX
       	    
            tosend = Encoder.highbyte       'Campo 4
            GoSub AsciiToHexTX              'Encoder actual highbyte
            CRC = CRC ^ Encoder.highbyte
            
            tosend = Encoder.lowbyte        'Campo 5
            GoSub AsciiToHexTX              'Encoder actual lowbyte     
            CRC = CRC ^ Encoder.lowbyte
            
        endif
        
            tosend = ConfirmByte            'Campo 6
            CRC = CRC ^ ConfirmByte         'ConfirmByte 
            GoSub AsciiToHexTX
            ConfirmByte = 0
            
            tosend = StatusByte             'Campo 7
            GoSub AsciiToHexTX              'StatusByte
            CRC = CRC ^ StatusByte          
            
            tosend = Vel                    'Campo 8
            CRC = CRC ^ Vel                 'Velocidad
            GoSub AsciiToHexTX
        
            tosend = NroMotor               'Campo 9
            GoSub AsciiToHexTX              'Nro Motor      
            CRC = CRC ^ NroMotor
            
            tosend = CRC                    'Campo 10
            GoSub AsciiToHexTX              'CRC          
                                                
            TXBYTE = 13                     'Transmito Cr + Lf
            GoSub TX
            
            TXBYTE = 10
            GoSub TX
            
        pauseus 500                  'Espero que transmita ultimo byte
        TXSTA.5 = 0   			     'Me aseguro de que este apagado transmisor
		tx485 = 0
  Return

'################################################################################
'RUTINAS DE TRANSMISION PUERTO SERIE HARD
'SI QUIERO ENVIAR EL ASCII EQUIVALENTE AL HEXA TENGO QUE 
'CARGAR ToSend CON CON EL BYTE A ENVIAR Y LLAMAR A AsciiToHexTX:
'ESTO VA A ENVIAR DOS CARACTERES POR EL PUERTO SERIE.
'EJEMPLO: ToSend = 255 ----> Envia caracter "F" + "F"
'Si quiero enviar el caracter binario cargar TXBYTE y llamar a TX:

AsciiToHexTX:
 
        temp = tosend >> 4        'Aislo 4 bits mas significativos
        GOSUB TXHex
        
        temp = tosend & %00001111 'Aislo 4 bits menos significativos 
        GOSUB TXHex
        return

TXHex:     
        lookup temp, ["0123456789ABCDEF"],TXBYTE 
        
TX:     
        IF PIR1.4 = 0 Then GoTo TX       'PIR1.4 = TXIF
        TXREG = TXBYTE
        Return
'################################################################################        
     
     
   
CheckRX:    
            
        IF rcsta.1 = 1 Then         'OverRun del Buffer de Recepcion
			RCSTA.4=0               'Inicializar Receptor
			RCSTA.4=1   		    'Inicializar Receptor
            Deep = 0
            return
        EndIF
        
	    IF PIR1.5 = 0 Then Return   '1 = hay datos en el buffer.
        
        if RCSTA.2 then             'Framing Error bit
		  tempRC = RCREG            'tengo que descartar ese byte
		  Deep = 0
          return                    'por eso lo leo para sacarlo del
        Else                        'Buffer
          tempRC = RCREG            
        endif                       
        
        if deep =0 then
            if temprc <> "@" then
                Deep = 0
            else
                pkt[0]="@"
                Deep = 1
                For temp = 1 TO 19
					Pkt[temp] = 0
 				Next temp
 			endif
            return   
        endif 
             
        if deep <18 then
                pkt[deep]=temprc
                if pkt[deep] = "@" then     'Si llega un "@" es que comenzo otra trama
                    deep = 1
                    return
                endif
                Deep = deep + 1
                return
        endif
        
        if deep = 18 then
            pkt[deep]=temprc
            if pkt[deep] = "@" then     'Si llega un "@" es que comenzo otra trama
                deep = 1
                return
            endif
                
            'Termino de recibir trama completa
            'hay que procesarla, chequear CRC y nroMotor.
            'Actuar en concecuencia.
            
            'Genero Array de Bytes RX Bin. Pasando la representacion Hex
            'que recibo a su equivalente en bytes Binario.
            'RXArray[0] = 64 "@" Inicio de trama
            'RXArray[1] = Numero de motor
            'RXArray[2] = Accion
            'RXArray[3] = Posicion MSB
            'RXArray[4] = Posicion LSB
            'RXArray[5] = TargetPos MSB
            'RXArray[6] = TargetPos LSB
            'RXArray[7] = Velocidad
            'RXArray[8] = Numero de confirmacion - ConfirmByteRX
            
            RXArray[0] = 64 ' "@"
            indiceRXarray = 0
            for temp = 1 to 17 step 2
                indiceRXarray = indiceRXarray+1
                hexRX =  pkt[temp]
                gosub HexToAscii
                RXArray[indiceRXarray] = binRX <<4
                hexRX =  pkt[temp+1]
                gosub HexToAscii
                RXArray[indiceRXarray] = RXArray[indiceRXarray] | binRX
            next temp
            
            'Calculo CRC
            CRC2 = 64   '"@"
            for temp = 1 to 8
                 CRC2 = CRC2 ^ RXArray[temp]
            next temp
            
            if CRC2 <> RXArray[9] then
                Deep = 0
                return
            endif
            
            if RXArray[1]<> nromotor then
                deep = 0
                return
            endif
            Deep = 0
            
            'La trama paso todas las pruebas.
            'A partir de aca a procesar.
            
            'Los posibles valores que puedo recibir en Accion son los
            'determinados en el enum ComandoMotor (Soft PC):
            'cReset = 1
            'cReporte = 2
            'cSubir = 3
            'cBajar = 4
            'cStop = 5
            'cPauseGoAutomatic = 6
            'cGoAutomatic = 7
            'cActualizarLimites = 8
' "p"       Reset equipo - Utilizada en PICs con reset por soft (18F)
' "g"       Transmitir a soft PC limites, posicion, etc, etc - Es la que utilizo para reportar
' "a"       Comando Subir
' "z"       Comando Bajar
' "x"       Comando Stop
' "j"       Detener GoAutomatic REEMPLAZADA POR STOP QUE LIMPIA BUFFER.
' "k"       Comando ir a automaticamente
' "s"       Comando actualizar final de carrera minEncoder
' "d"       Comando actualizar final de carrera maxEncoder


            'Este es el numero que debo enviar para chequear
            'que recibi ok la trama                            
            ConfirmByte = rxarray[8]    
            
            'Reset equipo
            IF rxarray[2] = 1 Then	     
                '@ reset
                Return
            EndIF
            
            'Transmitir a soft PC, posicion, etc, etc
            IF rxarray[2] = 2 Then	     
                GoSub INMEDIATE_TX
                Return
            EndIF
            
            'Comando Subir   
            IF rxarray[2] = 3 Then	     
                gosub inmediate_tx   'DEBUG
                
                'si esta superado en limite Sup salgo No tiene sentido seguir
                'y evito cargar tmpSubir en 1 para que no informe que esta UP.
                if Automatic = 1 then return
                if limsupsup = 1 then return    
                
                tmpSubir = 1
                tmpBajar = 0
                timeout = 0
                Vel = rxarray[7]
                
                'Para que en la proxima trama no informe limites.
                inflimit = 0                    
                Return
            EndIF
          
            'Comando Bajar
            IF rxarray[2] = 4 Then	     
                gosub inmediate_tx   'DEBUG
                'si esta superado en limite Inf salgo No tiene sentido seguir
                'y evito cargar tmpBajar en 1 para que no informe en DWN.
                if Automatic = 1 then return
                if liminfsup = 1 then return    
                tmpSubir = 0
                tmpBajar = 1
                timeout = 0
                Vel = rxarray[7]
                'Para que en la proxima trama no informe limites.
                inflimit = 0                
                Return  
            EndIF
            
            'Comando Stop
            IF rxarray[2] = 5 Then	     
                tmpSubir = 0
                tmpBajar = 0
                timeout = 0
                PORTB.0 = 0
                PORTB.1 = 0
                
                'Para que en la proxima trama no informe limites.
                inflimit = 0
                                
                'Limpio BufferRutinas y restablesco todo a cero
                'lo referido a Automatic
                Automatic = 0
                automaticpause = 0
                WR = 0
                rd = 0
                empty = 1
                full = 0
                statusbyte2 = 0
                
                gosub inmediate_tx   'DEBUG
                Return
            EndIF
            
            'Comando PausaGoAutomatic
            IF rxarray[2] = 6 Then	     
                'Para que en la proxima trama no informe limites.
                inflimit = 0  
                
                'Voy a escribit targetEncoder y Vel en Buffer
                gosub writebufferrutinas  
                
                gosub inmediate_tx   'DEBUG
                
                Return
            endif
            
            
            
            'Comando ir a automaticamente
            IF rxarray[2] = 7 Then	     
                'Para que en la proxima trama no informe limites.
                inflimit = 0  
                
                'Voy a escribit targetEncoder y Vel en Buffer
                gosub writebufferrutinas  
                
                gosub inmediate_tx   'DEBUG
                
                Return
            endif
            
            'Comando actualizar final de carrera minEncoder
            IF rxarray[2] = 8 Then	     
                
                gosub inmediate_tx   'DEBUG
                maxEncoder.HIGHBYTE = RXArray[3]
                temp = maxEncoder.HIGHBYTE
                write 3, temp
                pause 5
                
                maxEncoder.lowbyte = RXArray[4]
                temp = maxEncoder.lowbyte
                write 2, temp
                pause 5
                
                minEncoder.HIGHBYTE = RXArray[5]
                temp = minEncoder.HIGHBYTE
                write 1, temp
                pause 5
                
                minEncoder.lowbyte = RXArray[6]
                temp = minEncoder.lowbyte
                write 0, temp
                pause 5
           
            endif
            return
		 endif
		 
        IF PIR1.5 = 1 then goto CheckRX
        return
 
 
HexToAscii:
        lookdown hexRX, ["0123456789ABCDEF"],binRX
        return

subEncoder:
    'if portb.0 = 1 then         'DEBUG
    '    encoder = encoder + 10   'DEBUG
    '    return                  'DEBUG
    'endif                       'DEBUG
    'if portb.1 = 1 then         'DEBUG
    '    encoder = encoder - 10   'DEBUG
    '    return                  'DEBUG
    'endif                       'DEBUG
    'return                      'DEBUG
    
    porta.0 = 1 'Latch encoder
    pauseus 100
    encoder.highbyte = portd
    porta.1 = 1
    pauseus 20
    encoder.lowbyte = portd
    porta.1 = 0
    porta.0 = 0
    
    timeout = 0    
    Return

GoAutomatic:

    timeout = 0
    GoSub subEncoder
    
    'Si esta ejecutando una GoPausa
    if AutomaticPause > 0 then
        tmpSubir = 0
        tmpBajar = 0
        PORTB.0 = 0
        PORTB.1 = 0
        timeout = 0
        vel = 0
        return
    endif
    
    if automatic = 0 then
        'Si hay mas rutinas en bufferRutinas
        'la cargo y ejecuto. Sino apaga
        if Statusbyte2 > 0 then
        
            'Llamo para correr puntero RD
            gosub ReadBufferRutinas
            
            if encoder > targetencoder then
                Mayor =1
                tmpSubir = 0
                tmpBajar = 1
            else
                Mayor = 0
                tmpSubir = 1
                tmpBajar = 0
            endif
            automatic = 1
       endif
       return
    endif

    IF Mayor = 1 Then
        IF encoder <= targetencoder Then
           
                tmpSubir = 0
                tmpBajar = 0
                PORTB.0 = 0
                PORTB.1 = 0
                timeout = 0
                automatic = 0
                vel = 0
           
        EndIF
    Else
        IF encoder >= targetencoder Then
            
                tmpSubir = 0
                tmpBajar = 0
                PORTB.0 = 0
                PORTB.1 = 0
                timeout = 0
                automatic = 0
                vel = 0
        EndIF
    EndIF

    Return

CheckLimits:
       'return
        '***********************************************
        'Rutina para comandar las salidas de Up/Down
        'previo chequear los limites de carrera
        '***********************************************
    if porta.3 = 1 then   ' SI ESTA EN PAUSA
        inpause = 1
        PORTB.1 = 0
        PORTB.0 = 0 
        timeout = 0
        portb.4=0         'ACA Baja velocidad a 0 cuando esta en pausa
        portb.3=0                  
        portb.2=0
        return
    endif
    inpause = 0
    
    if Vel = 0 then                 
        portb.4=0                  
        portb.3=0
        portb.2=0
    endif
    if Vel = 1 then
        portb.4=0
        portb.3=0
        portb.2=1
    endif
    if Vel = 2 then
        portb.4=0
        portb.3=1
        portb.2=0
    endif
    if Vel = 3 then
        portb.4=0
        portb.3=1
        portb.2=1
    endif
    if Vel = 4 then
        portb.4=1
        portb.3=0
        portb.2=0
    endif
    if Vel = 5 then
        portb.4=1
        portb.3=0
        portb.2=1
    endif
    if Vel = 6 then
        portb.4=1
        portb.3=1
        portb.2=0
    endif
    if Vel >= 7 then
        portb.4=1
        portb.3=1
        portb.2=1
    endif
    
    
    
        if encoder >= maxEncoder then
            PORTB.0 = 0
            tmpSubir = 0
            'automatic = 0	'########################
            LimSupSup = 1
        else
            LimSupSup = 0
            portb.0 = tmpsubir
        endif            
        if encoder =< minEncoder then
            PORTB.1 = 0
            tmpbajar = 0
            'automatic = 0	'########################
            liminfsup = 1
        else
            liminfsup = 0
            portb.1 = tmpbajar
        endif
return
   
   
ReadBufferRutinas:

    'Esta rutina se encarga de leer en el Buffer
    'de rutinas. El buffer es FIFO circular. Correr el 
    'puntero RD para apuntar a targetEncoder, Vel y
    'de corresponder cargo el valor de pausa si el nivel
    'debuffer este corresponde a una pausa
    
    targetencoder = GoEncoder[rd]
    Vel = govel[rd]
    'Si este nivel de Buffer es una pausa cargo variable con
    'el valor de pausa correspondiente
    if gopause[RD] = 1 then
        AutomaticPause = GoEncoder[rd]
    else
        AutomaticPause = 0
    endif 
    
    if rd = wr then
        if Empty = 1 then return
    endif
    
    if rd = 4 then
        rd = 0
    else
        rd = rd + 1
    endif
    
    if rd = wr then
        empty = 1
    else
        full=0
    endif
    
    'Calculo cantidad de rutinas en BufferRutinas
    if wr > rd then
        statusbyte2 = wr - rd
    endif
    if wr = rd then
        if full = 1 then
            statusbyte2 = 5
        else
            statusbyte2 = 0
        endif
    endif
    if wr < rd then
        statusbyte2 = (5 - rd)+wr
    endif

return

WriteBufferRutinas:

    timeout = 0
    'Esta rutina se encarga de agregar en el Buffer de rutinas
    'y mover el puntero de escritura. El buffer es FIFO circular.

    if rd = wr then
        if full = 1 then return
    endif   

    goVel[wr] = rxarray[7]
    Acces_GoEncoder[(wr*2)+1] = RXArray[3]      'GoEncoder.hightbyte
    Acces_GoEncoder[wr*2] = RXArray[4]          'GoEncoder.lowbyte
    
    'Si el comando es GoPause, cargo el flag en array GoPause
    'para que pueda identificar GoAutomatic que este nivel de
    'Buffer es una pausa y no un movimiento.
    if rxarray[2] = 6 then
        gopause[wr] = 1
    else
        gopause[wr] = 0
    endif
    
    if wr = 4 then
        wr = 0
    else
        wr = wr + 1
    endif
    
    if rd = wr then
        full = 1
    else
        empty = 0
    endif
    
    'Calculo cantidad de rutinas en BufferRutinas
    if wr > rd then
        statusbyte2 = wr - rd
    endif
    if wr = rd then
        if full = 1 then
            statusbyte2 = 5
        else
            statusbyte2 = 0
        endif
    endif
    if wr < rd then
        statusbyte2 = (5 - rd)+wr
    endif
    
return

End
