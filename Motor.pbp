'****************************************************************
'*  Name    : MOTOR.pbp                                        *
'*  Author  : Juan Manuel Corino                                *
'*  Notice  : Copyright (c) 2018 Juan Manuel Corino             *
'*          : All Rights Reserved                               *
'*  Date    : 01/05/2018                                        *
'*  Version : 1.1                                               *
'*  Notes   : 16F887 @ 20Mhz                                   *
'*          :                                                   *
'****************************************************************
              'Test debug
'##################################################################
'Grabado Valores Iniciales en EEprom - Tabla db y parametros DSP
'Data @0,    0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,4

'Posicion 0-1 RESERVADA minEncoder
'Posicion 2-3 RESERVADA maxEncoder
        
'###################################################################
  
'#IF __PROCESSOR__ = "16F887"
 '   #CONFIG 
  '  __config _FOSC_HS & _WDT_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _LVP_OFF & _DEBUG_OFF &  _WRT_OFF & _BOR40V
   ' #ENDCONFIG
'#endif

INCLUDE "modedefs.bas"
Define LOADER_USED	1
DEFINE OSC 20           	'20Mhz Oscillator was used
'DEFINE HSER_CLROERR 1       'Hser clear overflow automatically
DEFINE SHIFT_PAUSEUS 10 

'CMCON = 7
ansel = 0
anselh = 0
IOCB = 0

rcsta = $90                 'Enable Asynchronous Serial Receive
txsta = $24                 'Enable Asynchronous Serial Transmit
'ICD---------------------
'spbrg = 64                  '19.2 KBaud @ 20Mhz
spbrg = 10                  '115.2 KBaud @ 20Mhz
'--------------------------
'spbrg = 25                  '19.2 KBaud @ 8Mhz
'option_reg = $87			'Set timer0 in TimerMode and prescaler 1:128
t1con = $25                 'Set Timer1 in TimerMode Prescaler 1:4
intcon.0 = 0
intcon.1 = 0
intcon.3 = 0
intcon.4 = 0
'intcon = 0

'intcon2.7 = 1              '18F4520
OPTION_REG.7 = 1            '16F887

TRISA.1 = 0                 'PIN 2 - Salida Seleccion LOW/HIGH Byte Encoder.
TRISA.0 = 0                 'PIN 3 - Salida Leer datos Encoder.

TRISA.2 = 1                 'PIN 4 - Entrada general 1.
TRISA.3 = 1                 'PIN 5 - Entrada general 2.
TRISA.4 = 1                 'PIN 6 - Entrada general 3.

TRISA.5 = 0                 'PIN 7 - Salida general 1.
TRISE.0 = 0                 'PIN 8 - Salida general 2.
TRISE.1 = 0                 'PIN 9 - Salida general 3. 

'TRISB.0 = 0                 'PIN 33 - Salida Boton Subir.
'TRISB.1 = 0                 'PIN 34 - Salida Boton Bajar.
'TRISB.2 = 0                 'PIN 35 - Salida Selector vel 1.
'TRISB.3 = 0                 'PIN 36 - Salida Selector vel 2.
'TRISB.4 = 0                 'PIN 37 - Salida Selector vel 3.

trisb = 0
portb = 0

TRISC.1 = 0                 'PIN 16 - Salida control TX RS485.

TRISC.2 = 0                 'PIN 17 - Salida Control Escritura EEPROM.
TRISC.3 = 0                 'PIN 18 - Salida SCK.
'TRISC.4 = 1                 'PIN 23 - Salida SDI.

TRISD.0 = 1                 'PIN 19 - Entrada encoder 0.
TRISD.1 = 1                 'PIN 20 - Entrada encoder 1.
TRISD.2 = 1                 'PIN 21 - Entrada encoder 2.
TRISD.3 = 1                 'PIN 22 - Entrada encoder 3.
TRISD.4 = 1                 'PIN 27 - Entrada encoder 4.
TRISD.5 = 1                 'PIN 28 - Entrada encoder 5.
TRISD.6 = 1                 'PIN 29 - Entrada encoder 6.
TRISD.7 = 1                 'PIN 30 - Entrada encoder 7.




'#################################################################
'Subir               VAR PORTB.0
'Bajar               VAR PORTB.1

DPIN                VAR PORTC.4         'I2C data pin
CPIN                VAR PORTC.3         'I2C clock pin
PORTC.2 = 0                             'TIENE QUE ESTAR EN 0 PARA QUE FUNCIONEN LAS MEMORIAS

tx485               var PORTC.1         'Control TX RS485.

'#################################################################

NroMotor            CON 1
NroMen              CON %10100000

ToSend              var byte

StatusByte          VAR BYTE
StatusByte1         VAR BYTE
StatusByte2         VAR BYTE
StatusByte3         VAR BYTE

'ErrorEnc			VAR	StatusByte.0       '1=Normal 0=Error Encoder
tmpSubir            VAR StatusByte.1
tmpBajar            VAR StatusByte.2
Automatic           VAR StatusByte.3        'Esta en 1 si esta haciendo GoAutomatic
LimSupSup           VAR StatusByte.4        'Si se supero Limite Superior
LimInfSup           VAR StatusByte.5        'Si se supero Limite Inferior


temp                VAR BYTE
tempRC              var byte

Deep                VAR BYTE
Ac_Seg              VAR BYTE
timeout             VAR BYTE
TXBYTE              VAR BYTE
Encoder             VAR WORD
Ac_MS               VAR BYTE

targetEncoder       VAR WORD
Mayor               VAR BIT

CRC2				VAR	BYTE
CRC					VAR	WORD

Vel                 VAR BYTE

maxEncoder          VAR WORD
minEncoder          VAR WORD

InfLimit            var bit
antTargetEncoder    var word
Pkt                 VAR BYTE[9]
tmpArray            VAR BYTE[8]

'#################################################################

Start:              'Inicio. LLamarla implica Soft-Reset

    Clear           'Inicializar todas las variables a cero
    portb = 0
    tx485 = 0
    TXSTA.5 = 0   			'Me aseguro de que este apagado transmisor
    
    pir1.0 = 0      'Cargo Timer
    TMR1L = 243
    TMR1H = 11
'#################################################################

read 0, temp
minEncoder.lowBYTE = temp
read 1, temp
minEncoder.HIGHBYTE = temp

read 2, temp
maxEncoder.lowBYTE = temp
read 3, temp
maxEncoder.HIGHBYTE = temp
          
Encoder = 32000

Loopp:

    IF pir1.0 = 1 Then 
        pir1.0 = 0
        TMR1L = 243
        TMR1H = 11
        GoSub subEncoder
        GoSub Timer_Sub
    EndIF
    
    GoSub CheckRX
    
    GoTo Loopp
    
Timer_Sub:
    
    IF timeout >= 4 Then   '200ms
        tmpbajar = 0
        tmpsubir = 0
        timeout = 0
        automatic = 0	'########################
    Else
        timeout = timeout + 1
    EndIF 
    
    IF Automatic = 1 Then
        GoSub GoAutomatic
    EndIF
    
    Ac_MS = Ac_MS + 1
    
    IF Ac_MS.0 = 1 Then        'Entro cada 100ms
    
        gosub CheckLimits
        
    EndIF
   
    if Ac_Seg >= 60 then    'Entro cada 3 Segundo
        Ac_Seg = 0
        inflimit = 1
    else
        Encoder = Encoder + 1 'DEBUG
        gosub INMEDIATE_TX    'DEBUG
        Ac_Seg = Ac_Seg +1
    endif
    
    Return
    
INMEDIATE_TX:
        
        CRC = 0
        tx485 = 1
		TXSTA.5 = 1                     'Activar transmisor
		
        TXBYTE = ":"                    'Envio de encabezado    Byte 1
        GoSub TX
        
        if inflimit = 1 then            'Campo 1
            tosend = 255                'Transmito 255 en HEX
            GoSub AsciiToHexTX
            CRC = CRC ^ 255 
        else
            tosend = statusbyte             
            CRC = CRC ^ statusbyte
            GoSub AsciiToHexTX        
        endif
        
        if inflimit = 1 then          'Campo 2
            tosend = maxencoder.highbyte   
            CRC = CRC ^ maxencoder.highbyte
            GoSub AsciiToHexTX   
        else
            tosend = StatusByte3   
            CRC = CRC ^ StatusByte3
            GoSub AsciiToHexTX        
        endif
        
        if inflimit = 1 then            'Campo 3    
            tosend = maxencoder.lowbyte      
       	    CRC = CRC ^ maxencoder.lowbyte
       	    GoSub AsciiToHexTX
        else
            tosend = StatusByte1      
       	    CRC = CRC ^ StatusByte1
       	    GoSub AsciiToHexTX
        endif
                
        tosend = StatusByte2                 'Campo 4
        CRC = CRC ^ StatusByte2          
        GoSub AsciiToHexTX
        
        if inflimit = 1 then
            tosend = minEncoder.highbyte
            GoSub AsciiToHexTX
            
            tosend = minEncoder.lowbyte
            GoSub AsciiToHexTX
            
            CRC = CRC ^ minencoder
        else
            tosend = Encoder.highbyte   'Envio estado highbyte Encoder
            GoSub AsciiToHexTX                    'Campo 5
        
            tosend = Encoder.lowbyte    'Envio estado lowbyte Encoder
            GoSub AsciiToHexTX                    'Campo 6
        
            CRC = CRC ^ Encoder
        endif
        
        tosend = vel                    'Campo 6Bis
        CRC = CRC ^ vel          
        GoSub AsciiToHexTX
        
        tosend = NroMotor           'Envio numero motor
        GoSub AsciiToHexTX                    'Campo 7
        CRC = CRC ^ NroMotor
        CRC = CRC ^ 43690
        
        tosend = CRC.highbyte       'Envio estado highbyte CRC
        GoSub AsciiToHexTX                    'Campo 8
        
        tosend = CRC.lowbyte        'Envio estado lowbyte CRC
        GoSub AsciiToHexTX                    'Campo 9
                                             
        TXBYTE = 13                'Transmito retroceso y salto de linea
        GoSub TX
        
        TXBYTE = 10
        GoSub TX
        

        if inflimit = 1 then
            inflimit = 0
        endif
        
        pauseus 500                  'Espero que transmita ultimo byte
        TXSTA.5 = 0   			     'Me aseguro de que este apagado transmisor
		tx485 = 0
        Return

'################################################################################
'RUTINAS DE TRANSMISION PUERTO SERIE HARD
'SI QUIERO ENVIAR EL ASCII EQUIVALENTE AL HEXA TENGO QUE 
'CARGAR ToSend CON CON EL BYTE A ENVIAR Y LLAMAR A AsciiToHexTX:
'ESTO VA A ENVIAR DOS CARACTERES POR EL PUERTO SERIE.
'EJEMPLO: ToSend = 255 ----> Envia caracter "F" + "F"
'Si quiero enviar el caracter binario cargar TXBYTE y llamar a TX:

AsciiToHexTX:
 
        temp = tosend >> 4        'Aislo 4 bits mas significativos
        GOSUB TXHex
        
        temp = tosend & %00001111 'Aislo 4 bits menos significativos 
        GOSUB TXHex
        return

TXHex:     
        lookup temp, ["0123456789ABCDEF"],TXBYTE 
        
TX:     
        IF PIR1.4 = 0 Then GoTo TX       'PIR1.4 = TXIF
        TXREG = TXBYTE
        Return
'################################################################################        
     
     
   
CheckRX:    
            
        IF rcsta.1 = 1 Then         'OverRun del Buffer de Recepcion
			RCSTA.4=0               'Inicializar Receptor
			RCSTA.4=1   		    'Inicializar Receptor
            Deep = 0
            return
        EndIF
        
	    IF PIR1.5 = 0 Then Return   '1 = hay datos en el buffer.
        
        if RCSTA.2 then             'Framing Error bit
		  tempRC = RCREG            'tengo que descartar ese byte
		  Deep = 0
          return                    'por eso lo leo para sacarlo del
        Else                        'Buffer
          tempRC = RCREG
        endif                       
        
		IF (tempRC = "i") and (Deep = 0)Then
				
				For temp = 1 TO 8
					Pkt[temp] = 0
 				Next temp
 				Pkt [0] = "i"
				Deep = 1
				CRC2 = 0
                IF PIR1.5 = 1 Then      '1 = hay datos en el buffer.
                    GoTo CheckRX        
                    return
                EndIF
                Return
		EndIF
		
		IF Deep = 0 Then
            IF pir1.5 = 1 Then      '1 = hay datos en el buffer.
                GoTo CheckRX        
                return
            EndIF
            Return
        EndIF
		 
		IF Deep < 8 Then 
			
			Pkt[Deep] = tempRC
			if deep = 7 then goto ContRX
			Deep = Deep + 1
            IF pir1.5 = 1 Then      '1 = hay datos en el buffer.
                GoTo CheckRX        
                return
            EndIF
            return    							
		EndIF
		
ContRX:



' "p"       Reset equipo - Utilizada en PICs con reset por soft (18F)
' "g"       Transmitir a soft PC limites, posicion, etc, etc - Es la que utilizo para reportar
' "a"       Comando Subir
' "z"       Comando Bajar
' "x"       Comando Stop
' "j"       Detener GoAutomatic DEBO UTILIZARLA - IMPLEMENTAR CODIGO
' "k"       Comando ir a automaticamente
' "s"       Comando actualizar final de carrera minEncoder
' "d"       Comando actualizar final de carrera maxEncoder

' "r"       Comando Reproducir Rutina grabada en EEPROM - NO UTILIZADA
' "b"       Comenzar a Grabar Datos PC a SD - NO UTILIZADA
' "c"       Comenzar a Grabar de PC a SD - NO UTILIZADA	
' "r"       Comando Reproducir Rutina grabada en EEPROM - NO UTILIZADA
' "l"       Comando Comenzar Grabacion Rutina en EEPROM   - NO UTILIZADA
' "q"       Comando Enviar Rutina a PC - NO UTILIZADA
' "n"       Comando Finalizar Grabacion o Reproduccion Rutina en EEPROM - NO UTILIZADA


	
		Deep = 0 
		
		IF (Pkt[7]= nromotor) or (Pkt[7]= 20) Then		'NUMERO DE MOTOR * 20= brodcast
			
            CRC2 =  Pkt[1] ^ Pkt[2] ^ Pkt[4] ^ Pkt[5] ^ Pkt[6] ^ Pkt[7] 	'CALCULA CRC de RECEPCION
								
			IF CRC2 <> Pkt[3] Then return
                        
            IF Pkt[1] = "p" Then	     'Reset equipo
                '@ reset
                Return
            EndIF
            
            IF Pkt[1] = "g" Then	     'Transmitir a soft PC limites, posicion, etc, etc
                GoSub INMEDIATE_TX
                Return
            EndIF
               
            IF Pkt[1] = "a" Then	     'Comando Subir
                tmpSubir = 1
                tmpBajar = 0
                timeout = 0
                Vel = Pkt[2]
                Return
            EndIF
          
            IF Pkt[1] = "z" Then	     'Comando Bajar
                tmpSubir = 0
                tmpBajar = 1
                timeout = 0
                Vel = Pkt[2]
                Return  
            EndIF
            
            IF Pkt[1] = "x" Then	     'Comando Stop
                tmpSubir = 0
                tmpBajar = 0
                timeout = 0
                PORTB.0 = 0
                PORTB.1 = 0
                Return
            EndIF
            
            IF Pkt[1] = "j" Then	     'Detener GoAutomatic
                ' IMPLEMENTAR CODIGO PARA DETERNER AUTOMATICOS
                Return
            EndIF
  
            IF Pkt[1] = "k" Then	     'Comando ir a automaticamente
                
                Automatic = 1
                'timeout = 0
                Vel = Pkt[2]
                targetEncoder.lowbyte = Pkt[5]
                targetEncoder.HIGHBYTE = Pkt[6]
                IF Pkt[4] = "1" Then
                    IF encoder <= targetencoder Then
                        timeout = 0
                        Automatic = 0
                        Mayor = 1
                        Return
                    EndIF
                    Mayor =1
                    tmpSubir = 0
                    tmpBajar = 1
                EndIF
                IF Pkt[4] = "2" Then
                    IF encoder >= targetencoder Then
                        timeout = 0
                        Automatic = 0
                        Mayor = 0
                        Return
                    EndIF
                    Mayor = 0
                    tmpSubir = 1
                    tmpBajar = 0
                EndIF 
                
                '##############################################
                '### 08/2011 control de DMX para que haga go
                '### calculando el sentido de giro acorde al
                '### targetEncoder
                IF Pkt[4] = "8" Then
                
                     if antTargetEncoder = Targetencoder then return
                     antTargetEncoder = TargetEncoder
                    'Para que quede en una posicion fija dentro de una ventana.
                    'y no tienda a no encontrar un punto fijo
                    if targetencoder < (encoder + 30) and targetencoder > (encoder - 30) then return
                    
                    if encoder > targetencoder then
                        Mayor =1
                        tmpSubir = 0
                        tmpBajar = 1
                    else
                        Mayor = 0
                        tmpSubir = 1
                        tmpBajar = 0
                    endif
                endif
                Return
            EndIF
            
            IF Pkt[1] = "s" Then	     'Comando actualizar final de carrera minEncoder
                
                minEncoder.lowbyte = Pkt[5]
                temp = minEncoder.lowbyte
                write 0, temp
                pause 5
                minEncoder.HIGHBYTE = Pkt[6]
                temp = minEncoder.HIGHBYTE
                write 1, temp
                pause 5
            endif
            
            IF Pkt[1] = "d" Then	     'Comando actualizar final de carrera maxEncoder
                
                maxEncoder.lowbyte = Pkt[5]
                temp = maxEncoder.lowbyte
                write 2, temp
                pause 5
                maxEncoder.HIGHBYTE = Pkt[6]
                temp = maxEncoder.HIGHBYTE
                write 3, temp
                pause 5
            endif
		EndIF
        
		Return       

subEncoder:
    'DEBUG
    return
    
    porta.0 = 1 'Latch encoder
    pauseus 100
    encoder.highbyte = portd
    porta.1 = 1
    pauseus 20
    encoder.lowbyte = portd
    porta.1 = 0
    porta.0 = 0
    
    timeout = 0    
    Return

GoAutomatic:

    timeout = 0
    GoSub subEncoder

    IF Mayor = 1 Then
        IF encoder <= targetencoder Then
           tmpSubir = 0
           tmpBajar = 0
           PORTB.0 = 0
           PORTB.1 = 0
           timeout = 0
           automatic = 0
            portb.4=0
            portb.3=0
            portb.2=0
        EndIF
    Else
        IF encoder >= targetencoder Then
           tmpSubir = 0
           tmpBajar = 0
           PORTB.0 = 0
           PORTB.1 = 0
           timeout = 0
           automatic = 0
            portb.4=0
            portb.3=0
            portb.2=0
        EndIF
    EndIF

    Return

CheckLimits:
       'return
        '***********************************************
        'Rutina para comandar las salidas de Up/Down
        'previo chequear los limites de carrera
        '***********************************************
    if porta.3 = 1 then   ' SI ESTA EN PAUSA
        PORTB.1 = 0
        PORTB.0 = 0 
        timeout = 0
        portb.4=0         'ACA Baja velocidad a 0 cuando esta en pausa
        portb.3=0                  
        portb.2=0
        return
    endif
    
    if vel = 0 then                 
        portb.4=0                  
        portb.3=0
        portb.2=0
    endif
    if vel = 1 then
        portb.4=0
        portb.3=0
        portb.2=1
    endif
    if vel = 2 then
        portb.4=0
        portb.3=1
        portb.2=0
    endif
    if vel = 3 then
        portb.4=0
        portb.3=1
        portb.2=1
    endif
    if vel = 4 then
        portb.4=1
        portb.3=0
        portb.2=0
    endif
    if vel = 5 then
        portb.4=1
        portb.3=0
        portb.2=1
    endif
    if vel = 6 then
        portb.4=1
        portb.3=1
        portb.2=0
    endif
    if vel >= 7 then
        portb.4=1
        portb.3=1
        portb.2=1
    endif
    
    
    
        if encoder >= maxEncoder then
            PORTB.0 = 0
            tmpSubir = 0
            'automatic = 0	'########################
            LimSupSup = 1
        else
            LimSupSup = 0
            'PORTB.0 = tmpsubir
            portb.0 = tmpsubir
        endif            
        if encoder =< minEncoder then
            PORTB.1 = 0
            tmpbajar = 0
            'automatic = 0	'########################
            liminfsup = 1
        else
            liminfsup = 0
            'PORTB.1 = tmpbajar
            portb.1 = tmpbajar
        endif
return
   
End
